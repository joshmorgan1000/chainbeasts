#include "neuropet/zk_proof_system.hpp"
#include <cstring>
#include <openssl/evp.h>
#include <vector>

extern "C" {
// Lookup table used to efficiently convert nibbles to hexadecimal
// characters. Two output characters are produced per input byte.
static const char* HEX = "0123456789abcdef";

/**
 * @brief Convert binary data to a null terminated hex string.
 *
 * Each byte of the input is expanded into two hexadecimal characters in
 * the output buffer. The caller must provide a buffer with size at least
 * ``2 * size + 1`` bytes.
 */
static void to_hex(const uint8_t* data, std::size_t size, char* out_hex) {
    for (size_t i = 0; i < size; ++i) {
        // Upper 4 bits go first, lower 4 bits second.
        out_hex[2 * i] = HEX[data[i] >> 4];
        out_hex[2 * i + 1] = HEX[data[i] & 0xf];
    }
    // Terminate the string
    out_hex[2 * size] = '\0';
}

/**
 * @brief Compute a SHA3-256 hash over a block of memory.
 *
 * This helper wraps OpenSSL's EVP interface which internally allocates a
 * digest context and processes the input in one shot. The resulting 32
 * byte digest is written to ``out``.
 */
static void keccak256_bytes(const uint8_t* data, std::size_t size, uint8_t* out) {
    unsigned int len = 32;
    EVP_Digest(data, size, out, &len, EVP_sha3_256(), nullptr);
}

/** Prime modulus used by the reference STARK implementation. */
static constexpr uint32_t PRIME = 0x7fffffff; // 2^31 - 1

/** Evaluation point for the polynomial. */
static constexpr uint32_t EVAL_X = 17;

/**
 * @brief Evaluate ``data`` as a polynomial at ``EVAL_X`` using FRI folding.
 *
 * The implementation performs a simple FRI reduction by recursively
 * combining coefficient pairs with the evaluation point. For odd
 * lengths a zero coefficient is assumed for the final term. While this
 * is not a full proof-of-low-degree, it mirrors the computation that a
 * production STARK would execute when evaluating the witness
 * polynomial.
 */
static uint32_t eval_poly(const int8_t* data, std::size_t len) {
    std::vector<uint32_t> coeffs(len);
    for (std::size_t i = 0; i < len; ++i) {
        int32_t c = static_cast<int32_t>(data[i]);
        if (c < 0)
            c += PRIME;
        coeffs[i] = static_cast<uint32_t>(c);
    }

    std::size_t n = len;
    uint64_t x = EVAL_X;
    while (n > 1) {
        std::size_t m = (n + 1) / 2;
        for (std::size_t i = 0; i < m; ++i) {
            uint64_t a = (2 * i < n) ? coeffs[2 * i] : 0;
            uint64_t b = (2 * i + 1 < n) ? coeffs[2 * i + 1] : 0;
            coeffs[i] = static_cast<uint32_t>((a + b * x) % PRIME);
        }
        n = m;
        x = (x * x) % PRIME;
    }
    return coeffs[0];
}

/**
 * @brief Generate a STARK proof for a block of INT8 data.
 *
 * The proof is the polynomial evaluation result encoded in hexadecimal. The
 * ``checkpoint_root`` is derived by hashing the 4 byte little-endian proof value
 * using KECCAK-256.
 */
void zk_generate_proof(const int8_t* data, std::size_t len, zk_proof_raw* out) {
    uint32_t val = eval_poly(data, len);
    to_hex(reinterpret_cast<const uint8_t*>(&val), sizeof(val), out->proof);
    uint8_t root_digest[32];
    keccak256_bytes(reinterpret_cast<const uint8_t*>(&val), sizeof(val), root_digest);
    to_hex(root_digest, sizeof(root_digest), out->root);
}

/**
 * @brief Verify a proof generated by ``zk_generate_proof``.
 *
 * The verification recomputes the proof and compares it against the supplied
 * values. A production implementation would invoke a true STARK verifier here.
 */
bool zk_verify_proof(const int8_t* data, std::size_t len, const zk_proof_raw* proof) {
    zk_proof_raw expected{};
    zk_generate_proof(data, len, &expected);
    return std::strcmp(expected.proof, proof->proof) == 0 &&
           std::strcmp(expected.root, proof->root) == 0;
}
}
